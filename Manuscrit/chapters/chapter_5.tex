\chapter{Processeur global}
\textit{En ayant proposé des contremesures pour le chemin de données et pour le chemin de contrôle, nous avons une protection à priori complète due pipeline de processeur contre les attaques en faute et par canaux auxiliaires. Cependant au-delà de regarder ces deux chemins de manières indépendantes il est intéressant de regarder l'architecture globale du processeur pour étudier si de nouvelles contremesures ne peuvent pas être misent en place.
Dans ce chapitre une contremesure, exploitant les principes de bases des processeurs c'est à dire exécuter des instructions, est présentée pour complexifier tout type d'attaques physiques.
Et en deuxième partie, nous verrons comment sont intégrées ces contremesures dans un pipeline d'un processeur RISC-V 32~bits. Avec les différentes interactions entre les contremesures qui renforcent la sécurité, mais aussi leurs adaptations pour cette architecture spécifique démontrant ainsi leur adaptabilité.}\\

\minitoc
\newpage


\section{Désynchronisation}

L'insertion de retards aléatoires dans l'exécution d'un algorithme cryptographique est une contre-mesure simple mais plutôt efficace ces attaques. À notre connaissance, les retards aléatoires sont largement utilisés pour la protection des implémentations cryptographiques dans les dispositifs embarqués, principalement les cartes à puce de par leur faible surcout. Il appartient à un groupe de contre-mesures de dissimulation qui introduisent un bruit supplémentaire (soit dans le domaine temporel, amplitude ou fréquentiel) aux fuites par canaux auxiliaires tout en n'éliminant pas d'information du signal en lui-même. Ceci est le contraire du masquage qui élimine la corrélation entre la fuite et les données sensibles. Le mélange de plusieurs contre-mesures de dissimulation et de masquage est souvent utilisé pour augmenter la complexité des attaques.


La plupart des attaques par canaux auxiliaires et par injections de fautes exigent que l'adversaire sache précisément quand les opérations cibles se produisent dans l'exécution. Cela permet de synchroniser plusieurs traces au moment de l'événement critique, comme dans le cas de l'analyse de puissance différentielle, ou d'injecter une perturbation dans les calculs au bon moment, comme dans le cas des attaques par injections de fautes. En introduisant des retards aléatoires dans l'exécution, la synchronisation est rompue, ce qui augmente la complexité de l'attaque. Parmi les différentes techniques de randomisation temporelle proposées dans la littérature, par exemple \cite{DBLP:conf/ches/CoronK09,DBLP:conf/ches/ClavierCD00}, on peut généralement distinguer les techniques logicielles, par exemple basées sur les délais aléatoire par interruption (RDI), des techniques matérielles, par exemple basées sur l'augmentation de la jitter de l'horloge. En général, plus les contre-mesures sont proches du matériel, plus les solutions pour les surmonter sont axées sur le traitement du signal \cite{DBLP:conf/wistp/GuilleyKLD11,DBLP:conf/ctrsa/WoudenbergWB11}. Dans ce contexte, il est intéressant de noter que de nombreuses évaluations de l'impact des contre-mesures (par exemple \cite{DBLP:conf/ctrsa/Mangard04}) prétraitent les traces de fuite en les intégrant. Quelque peu influencées par cette technique d'évaluation, des recherches sont menées pour augmenter au maximum la variabilité des injections de cycles factices pour améliorer la distribution statistique de l'échantillon aléatoire des retards, afin que leur intégration produise les traces les plus bruyantes possible. Mais d'autres évaluations se basant sur la reconnaissance de motif permettent d'éliminer les ajouts d'instructions \cite{DBLP:conf/cardis/DurvauxRSOV12}. En résumé, pour avoir des injections de code factice efficace, il faut augmenter la distribution statistique de l'échantillon aléatoire des retards et éviter que ces injections suivent un motif particulier.D'autres évaluations basées sur la reconnaissance de formes, en revanche, peuvent éliminer les ajouts d'instructions [7]. 
	Dans [7], les auteurs proposent des exigences pour une insertion efficace des instructions factices, ils devraient utiliser :
- des retards sans motif régulier
- des insertions qui ne sont pas prévisibles
- des retards qui ressemblent à l'instruction environnante
Les motifs réguliers sont difficiles à éviter pour les méthodes logicielles, car ces instructions nécessitent souvent des prologues. De plus, dans de nombreuses applications, nous ne pouvons pas nous permettre d'augmenter la taille du code. Seule l'insertion matérielle à l'exécution d'instructions factices permet d'éviter cette augmentation. Néanmoins, les solutions matérielles de l'état de l'art, telles que [8], [9], répondent aux deux premiers points en insérant aléatoirement des instructions sans motif, mais elles posent le problème de la distinction entre les instructions factices et les instructions réelles. Mais aussi dans la diversité et la cohérence des instructions insérées.

\subsection{Présentation de la contremesure}
La contre-mesure proposée est un système matériel capable d'insérer des instructions factices à des intervalles aléatoires pendant l'exécution du programme. Le but est de matérialiser le concept de cycle factice, qui est utilisé au moment de la compilation dans la grande majorité des propositions. Pour faciliter les explications de la réalisation, nous nous plaçons dans l'architecture RISC-V avec un processeur CV32E40P à quatre étages. Le choix de l'architecture du jeu d'instructions (ISA) et de l'architecture du processeur n'a pas d'incidence sur la pertinence de la solution. 
	L'architecture de la contre-mesure proposée, présentée sur la Figure 1, est divisée en deux parties : la génération de l'instruction avec le registre "dummy opcode" et le bloc "Generate random instr". Ensuite, l'injection de l'instruction dans le pipeline du processeur avec un multiplexeur est contrôlée par un diviseur de fréquence programmable "Variable div clock" et un bit aléatoire "RNG". Il y a aussi la propagation d'un signal "flag dummy" pour avertir les étapes suivantes si une instruction dummy est en cours.

\subsubsection{Génération de l'instruction factice}
La génération d'instructions factices devrait permettre d'obtenir des instructions aussi semblables que possible aux instructions valides, mais c'est un défi. La solution la plus courante consiste à créer les instructions fictives à partir d'opcodes arithmétiques prédéfinis. Cette solution permet de les générer en utilisant des instructions déjà traitées, ce qui permet d'utiliser la quasi-totalité de l'ISA comme instructions fictives. Seuls les éléments nécessaires à la détermination du type d'instruction doivent être sauvegardés. En observant les différents types d'instructions dans la figure 2, nous pouvons constater que seuls 17 bits du champ opcode, funct3 et funct7 sont utiles lors du décodage de l'instruction. Il est important de prêter attention aux instructions nécessitant un niveau de privilège particulier. Dans l'architecture RISC-V, ces instructions sont regroupées dans le SYSTEM opcode et sont ignorées dans notre solution pour éviter toute incohérence de privilège. 
	Ainsi, si seuls ces 17 bits sont sauvegardés et que les autres bits peuvent être choisis au hasard, le décodage devrait toujours être valide. Mais générer 15 bits aléatoires nécessite une implémentation coûteuse du RNG. Il est donc préférable de choisir ces 15 bits dans un état interne du processeur (parmi le registre de contrôle/état (CSR), les registres, le compteur de programme (PC), etc.) Sa sélection a peu de contraintes, elle doit juste changer assez fréquemment parmi un grand ensemble de valeurs. Elle présente également peu de problèmes de sécurité car les données manipulées sont utilisées pour la sélection de registres ou d'immédiats. Elle permet des entrées différentes pour les instructions à chaque exécution, et ajoute de la variabilité en randomisant le poids de Hamming de l'instruction fictive et la distance de Hamming avec les instructions authentiques suivantes et précédentes.

\subsubsection{Insertion de l'instruction factice}
L'insertion des instructions ne doit pas être prévisible. Il est nécessaire d'ajouter du hasard dans la décision d'insérer des instructions factices. Dans notre solution, un diviseur d'horloge variable fournit un signal d'horloge à la fréquence F*2 lorsque F est la fréquence cible d'insertion des instructions fictives. F peut être défini par un registre de configuration, par exemple un CSR. Dans notre implémentation, pour des raisons pratiques, nous utilisons un registre de 32 bits, extérieur au cœur du processeur, modifiable par JTAG. L'insertion d'une instruction est conditionnée par un multiplexeur commandé par la sortie d'une porte ET avec comme entrées la sortie d'un générateur de nombres aléatoires et la sortie du diviseur d'horloge. Il y a une chance sur deux pour que le signal de sortie du diviseur d'horloge traverse la porte AND, ce qui entraîne une fréquence moyenne d'insertion d'instruction fictive égale à F. À chaque période du signal du diviseur d'horloge, le système récupère une instruction et la stocke dans le registre "dummy opcode". La variabilité a encore augmenté car les opcodes stockés ne sont utilisés qu'une seule fois.
	 L'insertion des instructions factices se fait à l'étage DECOD. A ce moment, l'étape IF est gelée. L'exécution est reprise au cycle suivant de manière transparente pour le noyau. Ainsi, le flux normal d'exécution n'est pas perturbé et les interruptions sont toujours fonctionnelles.
	Avec une instruction fictive et les signaux générés pendant son exécution, nous devons nous assurer qu'elle ne perturbe pas le flux normal d'exécution. Le signal "dummy flag" informe le processeur qu'il exécute une instruction fictive.


\subsection{Modification de l'architecture}
	Il est difficile de définir toutes les modifications car elles dépendent fortement de l'architecture et de la mise en œuvre du processeur. Cependant, certaines considérations générales peuvent être soulevées. Tout d'abord, lorsque le processeur exécute une instruction fictive, aucune écriture en mémoire ou dans les registres légitimes n'est autorisée pour des raisons évidentes d'intégrité de la mémoire. En outre, il faut éviter que le processeur modifie les registres de contrôle, les drapeaux ou le PC ; par exemple, les instructions de saut et de branchement. Il est également nécessaire d'éviter que les résultats soient contournés. Comme proposé ci-dessous, il pourrait être intéressant de modifier l'architecture pour que ces cycles fictifs ressemblent davantage à des instructions légitimes.
	
\subsubsection{Écriture dans les registres et la mémoire}

L'écriture dans la banque de registres est un facteur distinctif qui peut être utilisé pour détecter les instructions factices. Pour éviter cela, nous n'écrivons que dans les registres qui ne sont pas utilisés par le flux d'exécution normal. Il n'est pas nécessaire de modifier quoi que ce soit pour les lectures dans les registres car seules les écritures influencent le véritable flux de contrôle. Comme tous les registres sont susceptibles d'être utilisés, il est nécessaire de prévoir deux registres de destination supplémentaires (shadow register). Dans le processeur CV32E40P, à chaque cycle, deux registres peuvent être écrits en même temps, un pour le résultat de l'ALU et un autre pour les accès à la mémoire. Cependant, l'écriture toujours dans les mêmes registres est identifiable. Il est alors possible d'implémenter un banc de registres dynamique, comme montré dans [10], pour utiliser les mêmes registres physiques pour les instructions factices et légitimes. 


Le banc de registres dynamique, dans la figure 3, est rendu possible en séparant les index de registres ciblés par l'ISA des registres physiques. L'index fait maintenant référence à une table de consultation pointant vers un emplacement de registre physique. Une table de validité des registres physiques doit être conservée afin de déterminer quel registre est utilisé.
 La table de validité consiste à ajouter un bit de validité à chaque registre de la banque. Lorsqu'un registre physique est écrit, il est considéré comme valide.  Il y a deux façons d'invalider un registre, la première est lors du retour d'une fonction. En effet lorsqu'une instruction ''RET'' est exécutée une partie des registres est sauvegardée et l'autre non. Ces registres non sauvegardés peuvent être considérés comme invalides. L'autre façon de désactiver un registre physique est de maintenir la nature dynamique de la banque de registres. Lors de l'écriture dans la banque de registres, le registre physique associé au registre ISA à écrire est d'abord invalidé, puis un nouveau registre physique est choisi parmi les registres libres. Ainsi, à chaque écriture dans un registre ISA, celui-ci est écrit dans un registre physique différent. La figure 4 illustre une écriture dans un registre ISA déjà affecté à un registre physique.
 
 
Le "bloc Nxt_register" tire un indice de registre au hasard parmi les registres non valides. La logique complexe de sélection est divulguée dans [10] avec une implémentation proche de la nôtre. Dans notre cas, nous avons jusqu'à deux écritures dans les registres par cycle, donc nous devons tirer au hasard deux registres différents. Ce dessin a été créé à l'aide d'un deuxième "bloc Nxt_register" avec des paramètres d'entrée différents. 
 Lorsque des instructions factices écrivent dans les registres, le registre écrit ne doit pas être validé. De plus, il n'est pas nécessaire d'effectuer l'étape d'invalidation susmentionnée. Par conséquent, avec le registre dynamique, la seule différence perceptible, du point de vue de l'attaquant, pour la manipulation du registre factice réside dans la gestion des bits de validité. 
 
 
La gestion des instructions Load/Store est un problème en raison de la difficulté de déterminer les espaces mémoire libres. Nous résolvons ce problème en attribuant une adresse unique à la lecture et à l'écriture de la mémoire.
	
	
\subsubsection{Sauts et branchements}

Les branches et les sauts étant des instructions courantes, nous devons trouver un moyen de les exécuter tout en restant aussi proche que possible du comportement original. Nous utilisons la même opération pour les sauts, mais au lieu de sauter à l'adresse indiquée dans l'opérande ou le registre, nous passons à l'instruction suivante. 


La même approche ne peut pas être utilisée pour les branchements ; en effet, si le branchement est effectué, le processeur doit annuler les instructions qui ont été exécutées avant le résultat du branchement. Par conséquent, les instructions seraient réexécutées, ce qui poserait un problème non seulement de détection mais aussi de fuite via des canaux secondaires. Par conséquent, nous avons été contraints de ne pas considérer les branches comme des instructions fictives.

\subsection{conclusion}

Nous avons présenté une solution hardware adapté au processeur généraliste avec un faible surcout. Elle consiste en l'injection de retard aléatoire basé sur l'injection d'instruction aléatoire factices dépendante du contexte d'exécution. Notre solution de par l'injection d'instruction randomisé déjà utilise sans prologue ni préambule, nous place dans un cadre optimal qui est impossible à atteindre par les solutions logicielles. Contrairement aux autres solutions matérielles nous proposons des instructions en cohérence avec le contexte d'exécution et nos instructions ont une grande variabilité et sont peu différentiable d'instruction légitime

\section{combinaison des contre-mesures}
\section{Implémentions dans le VT2/résultats}
\section{Conclusion}