\chapter{Conclusion}
Dans l'état de l'art, quelques solutions ont été apportées pour masquer le pipeline d'un processeur et aucune n'a proposé de solutions spécifiques aux attaques par injections de fautes. On ne trouve donc à fortiori aucun travail essayant de résoudre ces deux problèmes conjointement. 
C'est pourquoi cette thèse s'est concentrée sur l'adaptation aux contraintes spécifique d'un pipeline d'un CPU pour proposer des solutions innovantes avec toujours un attrait particulier au surcout matériel des solutions pour une intégration avec un coût raisonnable. Au-delà du surcout l'aspect facilement adaptable et généralisable à tout type d'architecture a été au centre de la démarche de recherche pour d'une part être intégré sur un large type de cible allant du micro contrôleur avec exécution dans l'ordre au processeur d'application avec exécution dans le désordre.

La solution a été de travailler sur des ensembles communs à tous les processeurs le chemin de contrôle et le chemin de donnée.
Pour le chemin de données, 3 solutions ont été proposées.
La première est l'ajout de tag d'intégrité. Ces tags sont générés à partir d'une permutation aléatoire. L'ajout de cette permutation aléatoire permet d'augmenter le niveau de sécurité face aux attaques par injections de fautes. En effet, de par la nature aléatoire de la permutation un attaquant même avec une connaissance parfaite du système ne peut pas s'assurer de sa capacité à injecter une faute valide.
La deuxième, bien que connue, est le masquage avec une réflexion sur celui le plus adapté au pipeline de processeur. Après avoir analysé les différents masquages à faible latence, il a été choisi de partir sur le masquage LMDPL qui offre le surcout matériel le plus faible et l'augmentation du chemin critique le plus contenu. Cette thèse apporte une méthode analytique pour construire ce masquage et montre ainsi que l'impossibilité d'un masquage de ce type pour les ordres supérieurs.
Enfin, des registres dynamiques sont proposés, bien qu'existant déjà dans l'état de l'art, il permet d'apporter une sécurité supplémentaire sur les registres en rendant aléatoire le placement des données dans les registres. En effet, ceux-ci sont la partie la plus sensible du chemin de données, mais apportent aussi des interactions fondamentales avec la contre-mesure des cycles factices.

Le chemin de contrôle quand a lui a été sécurisé à l'aide de méthode plus légère contre les canaux auxiliaires, car celui si est moins sensible aux d'attaques de ce type même si elle reste possible. Les sécurités se sont principalement concentrées contre les attaques en fautes avec la création de dépendance entre les instructions. En effet, la solution proposée est de générer un masque à l'aide des signaux de décodage de l'instruction précédente pour masquer l'instruction en cours. Le fait d'utiliser un masque permet de réduire le surcout de la redondance à quelques pour cent que ce soit en termes de taille de circuit mais aussi de temps d'exécution. De plus ce masque apporte une résistance face désassemblage bits à bits par canaux auxiliaires. Enfin, les signaux de contrôle sont sécurisé à l'aide d'une parité croise qui offre une sécurité importante face aux injections de fautes multiples avec un surcout faible.

Enfin d'un point de vue global nous proposons un système de désynchronisation temporelle aléatoire pour complexifier les attaques par injection de faute et par canaux auxiliaires. Celui-ci consiste en l'insertion d'instruction aléatoire qui sont peu différentiable d'instruction légitime.
Enfin nous avons implémenté ces différentes contre-mesures dans un véhicule de test qui a été fondu et qui va être testé par le CESTI du CEA-LETI.

De ces travaux de thèses nous pouvons en tirer quelques conclusions intéressantes. Tout d'abord l'ajout d'aléatoire contre les attaques en fautes est le niveau le plus avancé dans la prévention de ces attaques. En effet, il n'est plus possible pour un attaquant ayant une parfaite connaissance du système cible de pouvoir réaliser une attaque, mais cela permet aussi d'apporter de l'aléa dans les traces pour les canaux auxiliaires complexifiant ainsi l'analyse statistique.
D'autre part, l'approche du masquage et détection par le décodage des instructions permet d'avoir des solutions très légères pour la détection de faute au niveau des instructions.
Enfin la résilience passe par des indicateurs spécifiques a une attaque par injection de faute et c'est au logiciel de gérer ces cas là. En effet il est souvent trop complexe d'un point de vue matériel de gérer ces cas rares. La solution est la plus simple est la correction d'erreur, mais celle-ci offre de nouvelles opportunités d'attaques. Mais avec l'ajout de l'authenticité aux propriétés des contremesures pour les attaques par injections de fautes, la combinaison de sécurité et sûreté est réalisable sans compromettre l'un ou l'autre.
Ainsi cette thèse apporte une série de contributions pour une protection des principaux points clés d'un pipeline de processeurs contre les attaques par canaux auxiliaires et par injections de faute.

\section {Perspective}
Cependant certaines questions reste ouvertes ouvertes à la recherche notamment la résilience. En effet, même si nous avons mis en place des marqueurs spécifiques à une faute matérielle, il faut que le logiciel puisse gérer ces cas et avoir des procédures adapté à chacune des situations le cas le plus problématique soulevé dans cette thèse est celui d'une faute dans le banc de registre qui ne peut pas être adressé facilement.
De plus, la partie de génération de nombre aléatoire n'as pas été traité dans cette thèse est le choix de la génération de l'aléatoire a été laissé en suspends. 
Une autre piste de recherche est l'améliorer de SECDEC pour en faire un CFI complet et plus léger que les solutions proposées dans l'état de l'art.
D'autre part, bien qu'un masquage a été identifié il serait intéressant au vu de la nature généralisable et composable de LMDPL d'automatiser cette génération des fonctions masquées.
Enfin ces contre-mesures soient intégrées dans un processeur 32 bits et qu'elle semble généralisable à tout type d'architecture, la continuité naturelle est de tester l'intégration sur des architectures plus complexes avec des optimisations qui pourraient interagir avec nos contre-mesure et ouvrir de nouvelle piste d'amélioration des contremesure, on pourrait apr exemple étudier les interaction entre les cycles factice et l'exécution dans le désordre.